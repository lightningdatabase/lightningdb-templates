////////////////////////////////////////////////////////////////////////////////////////////////////
// DO NOT MODIFY THIS FILE                                                                        //
// This file is automatically generated by LightningDB Plugin and should not be manually updated. //
////////////////////////////////////////////////////////////////////////////////////////////////////

// @ts-nocheck
import { z } from "zod"
import type {
  AliasQuery,
  AtLeast,
  BoolFilter,
  DateTimeFilter,
  IntFilter,
  IntNullableFilter,
  SortOrder,
  StringFilter,
  StringNullableFilter,
  StringNullableListFilter,
  Includes,
  ExclusiveOneOf,
} from "@lightningdb/client/baseTypes"

export namespace LightningDB {
  const UserModel: z.ZodType<any> = z.lazy(() =>
    z.object({
      id: z.number(),
      email: z.string(),
      name: z.string().nullable(),
      posts: z.array(PostModel).optional(),
    }),
  )

  const PostModel: z.ZodType<any> = z.lazy(() =>
    z.object({
      id: z.number(),
      createdAt: z.coerce.date(),
      updatedAt: z.coerce.date(),
      title: z.string(),
      content: z.string().nullable(),
      published: z.boolean(),
      viewCount: z.number(),
      author: UserModel.optional().nullable(),
      authorId: z.number().nullable(),
    }),
  )

  export const lightningSchema = z.object({
    error: z.any().optional(),
    data: z
      .object({
        users: z.array(UserModel).optional(),
        posts: z.array(PostModel).optional(),
      })
      .optional(),
    deletes: z
      .object({
        users: z.array(z.object({ id: z.number() })).optional(),
        posts: z.array(z.object({ id: z.number() })).optional(),
      })
      .optional(),
    queryId: z.number().optional(),
  })

  export type TopLevelQueries = {
    users?: UsersQueryParams
    posts?: PostsQueryParams
    user?: UsersQueryParams
    post?: PostsQueryParams
  }

  export type AliasQueries =
    | AliasQuery<UsersQueryParams, "users">
    | AliasQuery<PostsQueryParams, "posts">

  type UsersQueryParams = {
    where?: UserWhereInput
    include?: UserInclude
    take?: number
    skip?: number
    orderBy?: UserOrderBy
  }

  type PostsQueryParams = {
    where?: PostWhereInput
    include?: PostInclude
    take?: number
    skip?: number
    orderBy?: PostOrderBy
  }

  type UserWhereInput = {
    id?: IntFilter | number
    email?: StringFilter | string
    name?: StringNullableFilter | string | null
    posts?: PostListRelationFilter
  }

  type PostWhereInput = {
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date
    updatedAt?: DateTimeFilter | Date
    title?: StringFilter | string
    content?: StringNullableFilter | string | null
    published?: BoolFilter | boolean
    viewCount?: IntFilter | number
    authorId?: IntNullableFilter | number | null
    author?: UserWhereInput | null
  }

  // @ts-ignore TS6196
  type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  // @ts-ignore TS6196
  type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  type UserInclude = {
    posts?: boolean | User$postsArgs
  }

  type PostInclude = {
    author?: boolean | Post$authorArgs
  }

  type UserOrderBy = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
  }

  type PostOrderBy = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    published?: SortOrder
    viewCount?: SortOrder
    authorId?: SortOrder
  }

  type User$postsArgs = {
    where?: PostWhereInput
    include?: PostInclude
    take?: number
    skip?: number
  }

  type Post$authorArgs = {
    where?: UserWhereInput
    include?: UserInclude
  }

  export type Models = {
    users: $UserPayload
    posts: $PostPayload
  }

  export type SingleModels = {
    user?: $UserPayload
    post?: $PostPayload
  }

  type $UserPayload = {
    name: "User"
    objects: {
      posts: $PostPayload[]
    }
    scalars: {
      id: number
      email: string
      name: string | null
    }
  }

  type $PostPayload = {
    name: "Post"
    objects: {
      author: $UserPayload
    }
    scalars: {
      id: number
      createdAt: Date
      updatedAt: Date
      title: string
      content: string | null
      published: boolean
      viewCount: number
      authorId: number | null
    }
  }

  export type MutationInput = ExclusiveOneOf<{
    users: ExclusiveOneOf<UserMutation>
    posts: ExclusiveOneOf<PostMutation>
  }>

  type UserMutation = {
    create?: UserCreateArgs
    createMany?: UserCreateManyArgs
    update?: UserUpdateArgs
    updateMany?: UserUpdateManyArgs
    upsert?: UserUpsertArgs
    delete?: UserDeleteArgs
    deleteMany?: UserDeleteManyArgs
  }

  type UserCreateArgs = {
    data: {
      id?: number
      email: string
      name?: string | null
    }
  }

  type UserCreateManyArgs = {
    data: {
      id?: number
      email: string
      name?: string | null
    }[]
    skipDuplicates?: boolean
  }

  type UserUpdateArgs = {
    where: UserWhereUniqueInput
    data: {
      id?: number
      email?: string
      name?: string | null
    }
  }

  type UserUpdateManyArgs = {
    where?: UserWhereInput
    data: {
      id?: number
      email?: string
      name?: string | null
    }
    limit?: number
  }

  type UserUpsertArgs = {
    where: UserWhereUniqueInput
    create: {
      id?: number
      email: string
      name?: string | null
    }
    update: {
      id?: number
      email?: string
      name?: string | null
    }
  }

  type UserDeleteArgs = {
    where: UserWhereUniqueInput
  }

  type UserDeleteManyArgs = {
    where?: UserWhereInput
  }

  type UserWhereUniqueInput = AtLeast<
    {
      id?: number
      email?: string
    },
    "id" | "email"
  >

  type PostMutation = {
    create?: PostCreateArgs
    createMany?: PostCreateManyArgs
    update?: PostUpdateArgs
    updateMany?: PostUpdateManyArgs
    upsert?: PostUpsertArgs
    delete?: PostDeleteArgs
    deleteMany?: PostDeleteManyArgs
  }

  type PostCreateArgs = {
    data: {
      id?: number
      createdAt?: Date
      updatedAt?: Date
      title: string
      content?: string | null
      published?: boolean
      viewCount?: number
      authorId?: number | null
    }
  }

  type PostCreateManyArgs = {
    data: {
      id?: number
      createdAt?: Date
      updatedAt?: Date
      title: string
      content?: string | null
      published?: boolean
      viewCount?: number
      authorId?: number | null
    }[]
    skipDuplicates?: boolean
  }

  type PostUpdateArgs = {
    where: PostWhereUniqueInput
    data: {
      id?: number
      createdAt?: Date
      updatedAt?: Date
      title?: string
      content?: string | null
      published?: boolean
      viewCount?: number
      authorId?: number | null
    }
  }

  type PostUpdateManyArgs = {
    where?: PostWhereInput
    data: {
      id?: number
      createdAt?: Date
      updatedAt?: Date
      title?: string
      content?: string | null
      published?: boolean
      viewCount?: number
      authorId?: number | null
    }
    limit?: number
  }

  type PostUpsertArgs = {
    where: PostWhereUniqueInput
    create: {
      id?: number
      createdAt?: Date
      updatedAt?: Date
      title: string
      content?: string | null
      published?: boolean
      viewCount?: number
      authorId?: number | null
    }
    update: {
      id?: number
      createdAt?: Date
      updatedAt?: Date
      title?: string
      content?: string | null
      published?: boolean
      viewCount?: number
      authorId?: number | null
    }
  }

  type PostDeleteArgs = {
    where: PostWhereUniqueInput
  }

  type PostDeleteManyArgs = {
    where?: PostWhereInput
  }

  type PostWhereUniqueInput = AtLeast<
    {
      id?: number
    },
    "id"
  >

  export const includesMap: Includes = {
    users: {
      posts: {
        type: "oneToMany",
        model: "posts",
        field: "authorId",
      },
    },
    posts: {
      author: {
        type: "manyToOne",
        model: "users",
        field: "authorId",
      },
    },
  }
}
