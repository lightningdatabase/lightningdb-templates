////////////////////////////////////////////////////////////////////////////////////////////////////
// DO NOT MODIFY THIS FILE                                                                        //
// This file is automatically generated by LightningDB Plugin and should not be manually updated. //
////////////////////////////////////////////////////////////////////////////////////////////////////

import { z } from "zod"
import {
  BoolFilter,
  DateTimeFilter,
  IntFilter,
  IntNullableFilter,
  SortOrder,
  StringFilter,
  StringNullableFilter,
} from "@lightningdb/server/types"
import type { Includes } from "@lightningdb/server/types"

const UserListRelationFilter: z.ZodType<
  | {
      every?: z.infer<typeof UserWhereInput>
      some?: z.infer<typeof UserWhereInput>
      none?: z.infer<typeof UserWhereInput>
    }
  | undefined
> = z.lazy(() => z
  .object({
    every: UserWhereInput,
    some: UserWhereInput,
    none: UserWhereInput,
  })
  .optional())

const PostListRelationFilter: z.ZodType<
  | {
      every?: z.infer<typeof PostWhereInput>
      some?: z.infer<typeof PostWhereInput>
      none?: z.infer<typeof PostWhereInput>
    }
  | undefined
> = z.lazy(() => z
  .object({
    every: PostWhereInput,
    some: PostWhereInput,
    none: PostWhereInput,
  })
  .optional())

const UserWhereInput = z
  .object({
    id: z.union([z.number(), IntFilter]).optional(),
    email: z.union([z.string(), StringFilter]).optional(),
    name: z.union([z.string(), StringNullableFilter]).optional().nullable(),
    posts: PostListRelationFilter,
    
  })
  .optional()

const PostWhereInput = z
  .object({
    id: z.union([z.number(), IntFilter]).optional(),
    createdAt: z.union([z.coerce.date(), DateTimeFilter]).optional(),
    updatedAt: z.union([z.coerce.date(), DateTimeFilter]).optional(),
    title: z.union([z.string(), StringFilter]).optional(),
    content: z.union([z.string(), StringNullableFilter]).optional().nullable(),
    published: z.union([z.boolean(), BoolFilter]).optional(),
    viewCount: z.union([z.number(), IntFilter]).optional(),
    authorId: z.union([z.number(), IntNullableFilter]).optional().nullable(),
    
    author: UserWhereInput.nullable(),
  })
  .optional()

const UserOrderBy = z
  .object({
    id: SortOrder,
    email: SortOrder,
    name: SortOrder,
  })
  .optional()

const PostOrderBy = z
  .object({
    id: SortOrder,
    createdAt: SortOrder,
    updatedAt: SortOrder,
    title: SortOrder,
    content: SortOrder,
    published: SortOrder,
    viewCount: SortOrder,
    authorId: SortOrder,
  })
  .optional()

const UserInclude: z.ZodType<
  | {
      posts?:
        | boolean
        | {
            where?: z.infer<typeof PostWhereInput>
            include?: z.infer<typeof PostInclude>
            take?: number
            skip?: number
          }
    }
  | undefined
> = z.lazy(() =>
  z
    .object({
      posts: z
        .union([
          z.boolean(),
          z.object({
            where: PostWhereInput,
            include: PostInclude,
            take: z.number().optional(),
            skip: z.number().optional(),
            orderBy: PostOrderBy,
          }),
        ])
        .optional(),
    })
    .optional(),
)

const PostInclude: z.ZodType<
  | {
      author?:
        | boolean
        | {
            where?: z.infer<typeof UserWhereInput>
            include?: z.infer<typeof UserInclude>
          }
    }
  | undefined
> = z.lazy(() =>
  z
    .object({
      author: z
        .union([
          z.boolean(),
          z.object({
            where: UserWhereInput,
            include: UserInclude,
          }),
        ])
        .optional(),
    })
    .optional(),
)

const usersQuery = z.object({
  table: z.literal("users"),
  where: UserWhereInput,
  include: UserInclude,
  take: z.number().optional(),
  skip: z.number().optional(),
  orderBy: UserOrderBy,
})

const postsQuery = z.object({
  table: z.literal("posts"),
  where: PostWhereInput,
  include: PostInclude,
  take: z.number().optional(),
  skip: z.number().optional(),
  orderBy: PostOrderBy,
})

export const lightningSchema = z.object({
  queries: z.array(z.union([usersQuery, postsQuery])).optional(),
  mutations: z
    .array(
      z.object({
        users: z
          .object({
            create: z
              .object({
                data: z.object({
                  id: z.number().optional(),
                  email: z.string(),
                  name: z.string().nullable(),
                }),
              })
              .optional(),
            createMany: z
              .object({
                data: z.array(
                  z.object({
                    id: z.number().optional(),
                    email: z.string(),
                    name: z.string().nullable(),
                  }),
                ),
              })
              .optional(),
            update: z
              .object({
                where: z
                  .object({
                    id: z.number().optional(),
                    email: z.string().optional(),
                  })
                  .refine(
                    data => data.id !== undefined || data.email !== undefined,
                    {
                      message: "id or email must be provided",
                    },
                  ),
                data: z.object({
                  id: z.number().optional(),
                  email: z.string().optional(),
                  name: z.string().optional().nullable(),
                }),
              })
              .optional(),
            updateMany: z
              .object({
                where: z
                  .object({
                    id: z.number().optional(),
                    email: z.string().optional(),
                    name: z.string().optional().nullable(),
                  })
                  .optional(),
                data: z.object({
                  id: z.number().optional(),
                  email: z.string().optional(),
                  name: z.string().optional().nullable(),
                }),
              })
              .optional(),
            upsert: z
              .object({
                where: z
                  .object({
                    id: z.number().optional(),
                    email: z.string().optional(),
                  })
                  .refine(
                    data => data.id !== undefined || data.email !== undefined,
                    {
                      message: "id or email must be provided",
                    },
                  ),
                create: z.object({
                  id: z.number().optional(),
                  email: z.string(),
                  name: z.string().nullable(),
                }),
                update: z.object({
                  id: z.number().optional(),
                  email: z.string().optional(),
                  name: z.string().optional().nullable(),
                }),
              })
              .optional(),
            delete: z
              .object({
                where: z
                  .object({
                    id: z.number().optional(),
                    email: z.string().optional(),
                  })
                  .refine(
                    data => data.id !== undefined || data.email !== undefined,
                    {
                      message: "id or email must be provided",
                    },
                  ),
              })
              .optional(),
            deleteMany: z
              .object({
                where: z
                  .object({
                    id: z.number().optional(),
                    email: z.string().optional(),
                    name: z.string().optional().nullable(),
                  })
                  .optional(),
              })
              .optional(),
          })
          .optional(),
        posts: z
          .object({
            create: z
              .object({
                data: z.object({
                  id: z.number().optional(),
                  createdAt: z.coerce.date().optional(),
                  updatedAt: z.coerce.date(),
                  title: z.string(),
                  content: z.string().nullable(),
                  published: z.boolean().optional(),
                  viewCount: z.number().optional(),
                  authorId: z.number().optional().nullable(),
                }),
              })
              .optional(),
            createMany: z
              .object({
                data: z.array(
                  z.object({
                    id: z.number().optional(),
                    createdAt: z.coerce.date().optional(),
                    updatedAt: z.coerce.date(),
                    title: z.string(),
                    content: z.string().nullable(),
                    published: z.boolean().optional(),
                    viewCount: z.number().optional(),
                    authorId: z.number().optional().nullable(),
                  }),
                ),
              })
              .optional(),
            update: z
              .object({
                where: z
                  .object({
                    id: z.number().optional(),
                  })
                  .refine(
                    data => data.id !== undefined,
                    {
                      message: "id must be provided",
                    },
                  ),
                data: z.object({
                  id: z.number().optional(),
                  createdAt: z.coerce.date().optional(),
                  updatedAt: z.coerce.date().optional(),
                  title: z.string().optional(),
                  content: z.string().optional().nullable(),
                  published: z.boolean().optional(),
                  viewCount: z.number().optional(),
                  authorId: z.number().optional().nullable(),
                }),
              })
              .optional(),
            updateMany: z
              .object({
                where: z
                  .object({
                    id: z.number().optional(),
                    createdAt: z.coerce.date().optional(),
                    updatedAt: z.coerce.date().optional(),
                    title: z.string().optional(),
                    content: z.string().optional().nullable(),
                    published: z.boolean().optional(),
                    viewCount: z.number().optional(),
                    authorId: z.number().optional().nullable(),
                  })
                  .optional(),
                data: z.object({
                  id: z.number().optional(),
                  createdAt: z.coerce.date().optional(),
                  updatedAt: z.coerce.date().optional(),
                  title: z.string().optional(),
                  content: z.string().optional().nullable(),
                  published: z.boolean().optional(),
                  viewCount: z.number().optional(),
                  authorId: z.number().optional().nullable(),
                }),
              })
              .optional(),
            upsert: z
              .object({
                where: z
                  .object({
                    id: z.number().optional(),
                  })
                  .refine(
                    data => data.id !== undefined,
                    {
                      message: "id must be provided",
                    },
                  ),
                create: z.object({
                  id: z.number().optional(),
                  createdAt: z.coerce.date().optional(),
                  updatedAt: z.coerce.date(),
                  title: z.string(),
                  content: z.string().nullable(),
                  published: z.boolean().optional(),
                  viewCount: z.number().optional(),
                  authorId: z.number().optional().nullable(),
                }),
                update: z.object({
                  id: z.number().optional(),
                  createdAt: z.coerce.date().optional(),
                  updatedAt: z.coerce.date().optional(),
                  title: z.string().optional(),
                  content: z.string().optional().nullable(),
                  published: z.boolean().optional(),
                  viewCount: z.number().optional(),
                  authorId: z.number().optional().nullable(),
                }),
              })
              .optional(),
            delete: z
              .object({
                where: z
                  .object({
                    id: z.number().optional(),
                  })
                  .refine(
                    data => data.id !== undefined,
                    {
                      message: "id must be provided",
                    },
                  ),
              })
              .optional(),
            deleteMany: z
              .object({
                where: z
                  .object({
                    id: z.number().optional(),
                    createdAt: z.coerce.date().optional(),
                    updatedAt: z.coerce.date().optional(),
                    title: z.string().optional(),
                    content: z.string().optional().nullable(),
                    published: z.boolean().optional(),
                    viewCount: z.number().optional(),
                    authorId: z.number().optional().nullable(),
                  })
                  .optional(),
              })
              .optional(),
          })
          .optional(),
      }),
    )
    .optional(),
  queryId: z.number().optional(),
})

export const tablesMap: Record<string, string> = {
  users: "users",
  posts: "posts",
}

export const includesMap: Includes = {
  users: {
    posts: {
      type: "oneToMany",
      model: "posts",
      field: "authorId",
    },
  },
  posts: {
    author: {
      type: "manyToOne",
      model: "users",
      field: "authorId",
    },
  },
}
